#pragma once

#include "datatypes.hpp"
#include "PointCloudUtilTypes.hpp"

#include "Constants.hpp"

#include <vector>
#include <cassert>
#include <string>

// Forward Declaration
namespace pointcloud
{
	struct sCloudPoint_t;
	struct sCloudPoint_FrameID_t;
	struct sCloudPoint_SensorInfo_t;
}

/**
 * Class to store a point clouds generated by a LiDAR sensor.
 */
class cRappPointCloud
{
public:
	typedef std::vector<rfm::sPoint3D_t>  vCloud_t;

	typedef std::vector<rfm::sPoint3D_t>::value_type				value_type;
	typedef std::vector<rfm::sPoint3D_t>::size_type					size_type;
	typedef std::vector<rfm::sPoint3D_t>::difference_type			difference_type;
	typedef std::vector<rfm::sPoint3D_t>::reference					reference;
	typedef std::vector<rfm::sPoint3D_t>::const_reference			const_reference;
	typedef std::vector<rfm::sPoint3D_t>::pointer					pointer;
	typedef std::vector<rfm::sPoint3D_t>::const_pointer				const_pointer;
	typedef std::vector<rfm::sPoint3D_t>::iterator					iterator;
	typedef std::vector<rfm::sPoint3D_t>::const_iterator			const_iterator;
	typedef std::vector<rfm::sPoint3D_t>::reverse_iterator			reverse_iterator;
	typedef std::vector<rfm::sPoint3D_t>::const_reverse_iterator	const_reverse_iterator;

public:
	cRappPointCloud();
	cRappPointCloud(const cRappPointCloud& pc) = default;
	virtual ~cRappPointCloud() = default;

	explicit cRappPointCloud(rfm::sCentroid_t centroid, const vCloud_t& pc);

	explicit cRappPointCloud(const std::vector<pointcloud::sCloudPoint_t>& in);
	explicit cRappPointCloud(const std::vector<pointcloud::sCloudPoint_FrameID_t>& in);
	explicit cRappPointCloud(const std::vector<pointcloud::sCloudPoint_SensorInfo_t>& in);

	cRappPointCloud& operator=(const cRappPointCloud& pc) = default;

	int id() const;

	const std::string& name() const;
	void setName(const std::string&);

	bool vegetationOnly() const;
	void setVegetationOnly(const bool vegetation_only);

	bool hasFrameIDs() const;
	bool hasPixelInfo() const;

    void clear();

    bool empty() const;

	void reserve(size_type new_cap);
	void resize(size_type count);
	void resize(size_type count, const value_type& value);

	size_type size() const;

	bool referenceValid() const;
	rfm::rappPoint_t referencePoint() const;
	void setReferencePoint(rfm::rappPoint_t point, bool valid = true);

	void addPoint(const rfm::sPoint3D_t& cloudPoint);

	void insert(const_iterator first, const_iterator last);

	void push_back(const rfm::sPoint3D_t& cloudPoint);

	const cRappPointCloud& operator+=(const cRappPointCloud& pc);

	void sort();

	/** SpiderCam uses millimeters **/
	int minX_mm() const;
	int maxX_mm() const;

	int minY_mm() const;
	int maxY_mm() const;

	int minZ_mm() const;
	int maxZ_mm() const;

	int length_mm() const;
	int width_mm() const;
	int height_mm() const;

	void recomputeBounds();

	rfm::rappPoint_t center() const;

	rfm::sCentroid_t centroid() const;

	rfm::sPoint3D_t getPoint(int x_mm, int y_mm, int r_mm) const;

	void rotate(double yaw_deg, double pitch_deg, double roll_deg);
	void translate(int dx_mm, int dy_mm, int dz_mm);

	void trim_outside(pointcloud::sBoundingBox_t box);

	void trim_below(int z_mm);
	void trim_above(int z_mm);

	iterator begin() { return mCloud.begin(); }
	const_iterator begin() const { return mCloud.begin(); }
	const_iterator cbegin() { return mCloud.cbegin(); }

	iterator end() { return mCloud.end(); }
	const_iterator end() const { return mCloud.end(); }
	const_iterator cend() { return mCloud.cend(); }

	reverse_iterator rbegin() { return mCloud.rbegin(); }
	const_reverse_iterator rbegin() const { return mCloud.rbegin(); }
	const_reverse_iterator crbegin() { return mCloud.crbegin(); }

	reverse_iterator rend() { return mCloud.rend(); }
	const_reverse_iterator rend() const { return mCloud.rend(); }
	const_reverse_iterator crend() { return mCloud.crend(); }

	rfm::sPoint3D_t& operator[](int i)       { return mCloud[i]; }
	rfm::sPoint3D_t  operator[](int i) const { return mCloud[i]; }

    const vCloud_t& data() const { return mCloud; }

	void disableFrameIDs();
	void enableFrameIDs();

	void disablePixelInfo();
	void enablePixelInfo();


private:
	int mID;

	std::string mName;

	int mMinX_mm = 0;
	int mMaxX_mm = 0;

	int mMinY_mm = 0;
	int mMaxY_mm = 0;

	int mMinZ_mm = 0;
	int mMaxZ_mm = 0;

	rfm::rappPoint_t mReferencePoint;
	bool mReferencePointValid = false;

	rfm::sCentroid_t mCentroid;

	bool mHasFrameIDs  = false;
	bool mHasPixelInfo = false;

	bool mEnableFrameIDs = true;
	bool mEnablePixelInfo = true;

	bool mVegetationOnly = false;

	vCloud_t mCloud;
};




