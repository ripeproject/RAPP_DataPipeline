
#include "PointCloud.hpp"

#include <cassert>

/******************************************************************************
 * 
 * Class to store a point clouds generated by generated by a LiDAR sensor.
 * 
 *****************************************************************************/

cPointCloudBase::cPointCloudBase()
{}

void cPointCloudBase::clear()
{
    mCloud.clear();
}

bool cPointCloudBase::empty() const
{
	return mCloud.empty();
}

std::size_t cPointCloudBase::size() const
{
    return mCloud.size();
}


/******************************************************************************
 *
 * Class to store a point clouds generated by one given frame of the sensor.
 * Each point in the point cloud represents one pixel of the sensor.  Invalid
 * points are stored as x=0, y=0, and z=0.
 *
 *****************************************************************************/


 /////////////////////////////////////////////////////////////////////////////////////
 // View
 /////////////////////////////////////////////////////////////////////////////////////

cSensorPointCloudByFrame::view::view(const_pointer start, const_pointer last, std::size_t stride)
	: mpStart(start), mpLast(last), mStride(stride)
{}

bool cSensorPointCloudByFrame::view::empty() const
{
	return mpLast == mpStart;
}

std::size_t cSensorPointCloudByFrame::view::size() const
{
	if (mpLast == mpStart) return 0;
	return (std::distance(mpStart, mpLast) / mStride) + 1;
}

cSensorPointCloudByFrame::view::const_reference cSensorPointCloudByFrame::view::operator[](std::size_t i) const
{
	return *(mpStart + i * mStride);
}


/////////////////////////////////////////////////////////////////////////////////////
// Span
/////////////////////////////////////////////////////////////////////////////////////
cSensorPointCloudByFrame::span::span(pointer start, pointer last, std::size_t stride)
	: mpStart(start), mpLast(last), mStride(stride)
{}

bool cSensorPointCloudByFrame::span::empty() const
{
	return mpLast == mpStart;
}

std::size_t cSensorPointCloudByFrame::span::size() const
{
	if (mpLast == mpStart) return 0;
	return (std::distance(mpStart, mpLast) / mStride) + 1;
}

cSensorPointCloudByFrame::span::const_reference cSensorPointCloudByFrame::span::operator[](std::size_t i) const
{
	return *(mpStart + i * mStride);
}

cSensorPointCloudByFrame::span::reference cSensorPointCloudByFrame::span::operator[](std::size_t i)
{
	return *(mpStart + i * mStride);
}

cSensorPointCloudByFrame::view cSensorPointCloudByFrame::span::to_view() const
{
	return view(mpStart, mpLast, mStride);
}


/////////////////////////////////////////////////////////////////////////////////////
// Sensor Point Cloud By Frame
/////////////////////////////////////////////////////////////////////////////////////
cSensorPointCloudByFrame::cSensorPointCloudByFrame()
    : mFrameID(0), mTimestamp_ns(0), mNumOfChannelsPerColumn(0), mNumOfColumnsPerFrame(0)
{}

void cSensorPointCloudByFrame::frameID(uint16_t id)
{
    mFrameID = id;
}

void cSensorPointCloudByFrame::timestamp_ns(uint64_t ts)
{
    mTimestamp_ns = ts;
}

std::size_t cSensorPointCloudByFrame::channelsPerColumn() const
{
	return mNumOfChannelsPerColumn;
}

std::size_t cSensorPointCloudByFrame::columnsPerFrame() const
{
	return mNumOfColumnsPerFrame;
}

void cSensorPointCloudByFrame::resize(std::uint16_t pixels_per_column, uint16_t columns_per_frame)
{
	mNumOfChannelsPerColumn = pixels_per_column;
	mNumOfColumnsPerFrame = columns_per_frame;
	mCloud.resize(pixels_per_column * columns_per_frame);
}

cSensorPointCloudByFrame::view cSensorPointCloudByFrame::channels(uint16_t column) const
{
	return view(&mCloud[column * mNumOfChannelsPerColumn],
				&mCloud[(column + 1) * mNumOfChannelsPerColumn - 1], 1);
}

cSensorPointCloudByFrame::span cSensorPointCloudByFrame::channels(uint16_t column)
{
	return span(&mCloud[column * mNumOfChannelsPerColumn],
				&mCloud[(column + 1) * mNumOfChannelsPerColumn - 1], 1);
}

const pointcloud::sCloudPoint_t& cSensorPointCloudByFrame::get(uint16_t column, uint16_t chn) const
{
	return mCloud[chn + column * mNumOfChannelsPerColumn];
}

void cSensorPointCloudByFrame::set(uint16_t column, uint16_t chn, const pointcloud::sCloudPoint_t& v)
{
	assert(chn < mNumOfChannelsPerColumn);
	assert(column < mNumOfColumnsPerFrame);

	mCloud[chn + column * mNumOfChannelsPerColumn] = v;
}


/******************************************************************************
 *
 * Class to store a reduced point clouds generated by one given frame of the sensor.
 * Invalid points (x=0, y=0, and z=0) are not stored in the point cloud.
 *
 *****************************************************************************/

cReducedPointCloudByFrame::cReducedPointCloudByFrame()
    : mFrameID(0), mTimestamp_ns(0)
{}

void cReducedPointCloudByFrame::frameID(uint16_t id)
{
    mFrameID = id;
}

void cReducedPointCloudByFrame::timestamp_ns(uint64_t ts)
{
    mTimestamp_ns = ts;
}

void cReducedPointCloudByFrame::resize(std::size_t num_of_points)
{
	mCloud.resize(num_of_points);
}

void cReducedPointCloudByFrame::set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint)
{
	if (point < mCloud.size())
		mCloud[point] = cloudPoint;
}

void cReducedPointCloudByFrame::addPoint(const pointcloud::sCloudPoint_t& cloudPoint)
{
    if ((cloudPoint.X_m == 0.0) && (cloudPoint.Y_m == 0.0) && (cloudPoint.Z_m == 0.0))
        return;

    mCloud.push_back(cloudPoint);
}

/******************************************************************************
 *
 * Class to store a point clouds generated by one given frame of the sensor.
 *
 *****************************************************************************/

void cPointCloud::resize(std::size_t num_of_points)
{
	mCloud.resize(num_of_points);
}

void cPointCloud::set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint)
{
	if (point < mCloud.size())
		mCloud[point] = cloudPoint;
}

void cPointCloud::addPoint(const pointcloud::sCloudPoint_t& cloudPoint)
{
	if ((cloudPoint.X_m == 0.0) && (cloudPoint.Y_m == 0.0) && (cloudPoint.Z_m == 0.0))
		return;

	mCloud.push_back(cloudPoint);
}

