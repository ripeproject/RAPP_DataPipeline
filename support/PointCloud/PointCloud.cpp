
#include "PointCloud.hpp"


/******************************************************************************
 * 
 * Classes to store a point clouds generated by generated by a LiDAR sensor.
 * 
 *****************************************************************************/


/******************************************************************************
 *
 * Class to store a reduced point clouds generated by one given frame of the sensor.
 * Invalid points (x=0, y=0, and z=0) are not stored in the point cloud.
 *
 *****************************************************************************/

 /////////////////////////////////////////////////////////////////////////////////////
 // Reduced Point Cloud By Frame
 /////////////////////////////////////////////////////////////////////////////////////

cReducedPointCloudByFrame::cReducedPointCloudByFrame(const cReducedPointCloudByFrame_FrameId& pc)
{
	mMinX = pc.minX();
	mMaxX = pc.maxX();

	mMinY = pc.minY();
	mMaxY = pc.maxY();

	mMinZ = pc.minZ();
	mMaxZ = pc.maxZ();

	mHasPoints = (mMinX != 0.0) || (mMaxX != 0.0) || (mMinY != 0.0) || (mMaxY != 0.0)
		|| (mMinZ != 0.0) || (mMaxZ != 0.0);

	auto n = pc.size();
	mCloud.resize(n);

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		mCloud[i] = data[i];
	}
}

cReducedPointCloudByFrame::cReducedPointCloudByFrame(const cReducedPointCloudByFrame_SensorInfo& pc)
{
	mMinX = pc.minX();
	mMaxX = pc.maxX();

	mMinY = pc.minY();
	mMaxY = pc.maxY();

	mMinZ = pc.minZ();
	mMaxZ = pc.maxZ();

	mHasPoints = (mMinX != 0.0) || (mMaxX != 0.0) || (mMinY != 0.0) || (mMaxY != 0.0)
		|| (mMinZ != 0.0) || (mMaxZ != 0.0);

	auto n = pc.size();
	mCloud.resize(n);

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		mCloud[i] = data[i];
	}
}


/////////////////////////////////////////////////////////////////////////////////////
// Reduced Point Cloud By Frame with Frame ID info
/////////////////////////////////////////////////////////////////////////////////////

cReducedPointCloudByFrame_FrameId::cReducedPointCloudByFrame_FrameId(const cReducedPointCloudByFrame_SensorInfo& pc)
{
	mMinX = pc.minX();
	mMaxX = pc.maxX();

	mMinY = pc.minY();
	mMaxY = pc.maxY();

	mMinZ = pc.minZ();
	mMaxZ = pc.maxZ();

	mHasPoints = (mMinX != 0.0) || (mMaxX != 0.0) || (mMinY != 0.0) || (mMaxY != 0.0)
		|| (mMinZ != 0.0) || (mMaxZ != 0.0);

	auto n = pc.size();
	mCloud.resize(n);

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		mCloud[i] = data[i];
	}
}

cReducedPointCloudByFrame_FrameId& cReducedPointCloudByFrame_FrameId::operator=(const cReducedPointCloudByFrame_SensorInfo& pc)
{
	mMinX = pc.minX();
	mMaxX = pc.maxX();

	mMinY = pc.minY();
	mMaxY = pc.maxY();

	mMinZ = pc.minZ();
	mMaxZ = pc.maxZ();

	mHasPoints = (mMinX != 0.0) || (mMaxX != 0.0) || (mMinY != 0.0) || (mMaxY != 0.0)
		|| (mMinZ != 0.0) || (mMaxZ != 0.0);

	auto n = pc.size();
	mCloud.resize(n);

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		mCloud[i] = data[i];
	}

	return *this;
}


 /////////////////////////////////////////////////////////////////////////////////////
 // Reduced Point Cloud By Frame with Frame ID and Sensor Info
 /////////////////////////////////////////////////////////////////////////////////////



 /////////////////////////////////////////////////////////////////////////////////////
 //  Point Cloud Data
 /////////////////////////////////////////////////////////////////////////////////////

cPointCloud::cPointCloud(const cPointCloud_FrameId& pc)
{
	mMinX = pc.minX();
	mMaxX = pc.maxX();

	mMinY = pc.minY();
	mMaxY = pc.maxY();

	mMinZ = pc.minZ();
	mMaxZ = pc.maxZ();

	mHasPoints = (mMinX != 0.0) || (mMaxX != 0.0) || (mMinY != 0.0) || (mMaxY != 0.0)
		|| (mMinZ != 0.0) || (mMaxZ != 0.0);

	auto n = pc.size();
	mCloud.resize(n);

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		mCloud[i] = data[i];
	}
}

cPointCloud::cPointCloud(const cPointCloud_SensorInfo& pc)
{
	mMinX = pc.minX();
	mMaxX = pc.maxX();

	mMinY = pc.minY();
	mMaxY = pc.maxY();

	mMinZ = pc.minZ();
	mMaxZ = pc.maxZ();

	mHasPoints = (mMinX != 0.0) || (mMaxX != 0.0) || (mMinY != 0.0) || (mMaxY != 0.0)
		|| (mMinZ != 0.0) || (mMaxZ != 0.0);

	auto n = pc.size();
	mCloud.resize(n);

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		mCloud[i] = data[i];
	}
}

void cPointCloud::resize(std::size_t num_of_points)
{
	mCloud.resize(num_of_points);
}

void cPointCloud::set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint)
{
	if (point < mCloud.size())
	{
		if (mHasPoints)
		{
			if (cloudPoint.X_m < mMinX)
				mMinX = cloudPoint.X_m;

			if (cloudPoint.X_m > mMaxX)
				mMaxX = cloudPoint.X_m;

			if (cloudPoint.Y_m < mMinY)
				mMinY = cloudPoint.Y_m;

			if (cloudPoint.Y_m > mMaxY)
				mMaxY = cloudPoint.Y_m;

			if (cloudPoint.Z_m < mMinZ)
				mMinZ = cloudPoint.Z_m;

			if (cloudPoint.Z_m > mMaxZ)
				mMaxZ = cloudPoint.Z_m;
		}
		else
		{
			mHasPoints = true;
			mMinX = mMaxX = cloudPoint.X_m;
			mMinY = mMaxY = cloudPoint.Y_m;
			mMinZ = mMaxZ = cloudPoint.Z_m;
		}

		mCloud[point] = cloudPoint;
	}
}

void cPointCloud::addPoint(const pointcloud::sCloudPoint_t& cloudPoint)
{
	if ((cloudPoint.X_m == 0.0) && (cloudPoint.Y_m == 0.0) && (cloudPoint.Z_m == 0.0))
		return;

	if (mHasPoints)
	{
		if (cloudPoint.X_m < mMinX)
			mMinX = cloudPoint.X_m;

		if (cloudPoint.X_m > mMaxX)
			mMaxX = cloudPoint.X_m;

		if (cloudPoint.Y_m < mMinY)
			mMinY = cloudPoint.Y_m;

		if (cloudPoint.Y_m > mMaxY)
			mMaxY = cloudPoint.Y_m;

		if (cloudPoint.Z_m < mMinZ)
			mMinZ = cloudPoint.Z_m;

		if (cloudPoint.Z_m > mMaxZ)
			mMaxZ = cloudPoint.Z_m;
	}
	else
	{
		mHasPoints = true;
		mMinX = mMaxX = cloudPoint.X_m;
		mMinY = mMaxY = cloudPoint.Y_m;
		mMinZ = mMaxZ = cloudPoint.Z_m;
	}

	mCloud.push_back(cloudPoint);
}


 /////////////////////////////////////////////////////////////////////////////////////
 // Point Cloud with Frame ID info
 /////////////////////////////////////////////////////////////////////////////////////

cPointCloud_FrameId::cPointCloud_FrameId(const cPointCloud_SensorInfo& pc)
{
	mMinX = pc.minX();
	mMaxX = pc.maxX();

	mMinY = pc.minY();
	mMaxY = pc.maxY();

	mMinZ = pc.minZ();
	mMaxZ = pc.maxZ();

	mHasPoints = (mMinX != 0.0) || (mMaxX != 0.0) || (mMinY != 0.0) || (mMaxY != 0.0)
		|| (mMinZ != 0.0) || (mMaxZ != 0.0);

	auto n = pc.size();
	mCloud.resize(n);

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		mCloud[i] = data[i];
	}
}

void cPointCloud_FrameId::resize(std::size_t num_of_points)
{
	mCloud.resize(num_of_points);
}

void cPointCloud_FrameId::set(std::size_t point, const pointcloud::sCloudPoint_FrameID_t& cloudPoint)
{
	if (point < mCloud.size())
	{
		if (mHasPoints)
		{
			if (cloudPoint.X_m < mMinX)
				mMinX = cloudPoint.X_m;

			if (cloudPoint.X_m > mMaxX)
				mMaxX = cloudPoint.X_m;

			if (cloudPoint.Y_m < mMinY)
				mMinY = cloudPoint.Y_m;

			if (cloudPoint.Y_m > mMaxY)
				mMaxY = cloudPoint.Y_m;

			if (cloudPoint.Z_m < mMinZ)
				mMinZ = cloudPoint.Z_m;

			if (cloudPoint.Z_m > mMaxZ)
				mMaxZ = cloudPoint.Z_m;
		}
		else
		{
			mHasPoints = true;
			mMinX = mMaxX = cloudPoint.X_m;
			mMinY = mMaxY = cloudPoint.Y_m;
			mMinZ = mMaxZ = cloudPoint.Z_m;
		}

		mCloud[point] = cloudPoint;
	}
}

void cPointCloud_FrameId::addPoint(const pointcloud::sCloudPoint_FrameID_t& cloudPoint)
{
	if ((cloudPoint.X_m == 0.0) && (cloudPoint.Y_m == 0.0) && (cloudPoint.Z_m == 0.0))
		return;

	if (mHasPoints)
	{
		if (cloudPoint.X_m < mMinX)
			mMinX = cloudPoint.X_m;

		if (cloudPoint.X_m > mMaxX)
			mMaxX = cloudPoint.X_m;

		if (cloudPoint.Y_m < mMinY)
			mMinY = cloudPoint.Y_m;

		if (cloudPoint.Y_m > mMaxY)
			mMaxY = cloudPoint.Y_m;

		if (cloudPoint.Z_m < mMinZ)
			mMinZ = cloudPoint.Z_m;

		if (cloudPoint.Z_m > mMaxZ)
			mMaxZ = cloudPoint.Z_m;
	}
	else
	{
		mHasPoints = true;
		mMinX = mMaxX = cloudPoint.X_m;
		mMinY = mMaxY = cloudPoint.Y_m;
		mMinZ = mMaxZ = cloudPoint.Z_m;
	}

	mCloud.push_back(cloudPoint);
}


 /////////////////////////////////////////////////////////////////////////////////////
 // Point Cloud with Frame ID and Sensor Info
 /////////////////////////////////////////////////////////////////////////////////////

void cPointCloud_SensorInfo::resize(std::size_t num_of_points)
{
	mCloud.resize(num_of_points);
}

void cPointCloud_SensorInfo::set(std::size_t point, const pointcloud::sCloudPoint_SensorInfo_t& cloudPoint)
{
	if (point < mCloud.size())
	{
		if (mHasPoints)
		{
			if (cloudPoint.X_m < mMinX)
				mMinX = cloudPoint.X_m;

			if (cloudPoint.X_m > mMaxX)
				mMaxX = cloudPoint.X_m;

			if (cloudPoint.Y_m < mMinY)
				mMinY = cloudPoint.Y_m;

			if (cloudPoint.Y_m > mMaxY)
				mMaxY = cloudPoint.Y_m;

			if (cloudPoint.Z_m < mMinZ)
				mMinZ = cloudPoint.Z_m;

			if (cloudPoint.Z_m > mMaxZ)
				mMaxZ = cloudPoint.Z_m;
		}
		else
		{
			mHasPoints = true;
			mMinX = mMaxX = cloudPoint.X_m;
			mMinY = mMaxY = cloudPoint.Y_m;
			mMinZ = mMaxZ = cloudPoint.Z_m;
		}

		mCloud[point] = cloudPoint;
	}
}

void cPointCloud_SensorInfo::addPoint(const pointcloud::sCloudPoint_SensorInfo_t& cloudPoint)
{
	if ((cloudPoint.X_m == 0.0) && (cloudPoint.Y_m == 0.0) && (cloudPoint.Z_m == 0.0))
		return;

	if (mHasPoints)
	{
		if (cloudPoint.X_m < mMinX)
			mMinX = cloudPoint.X_m;

		if (cloudPoint.X_m > mMaxX)
			mMaxX = cloudPoint.X_m;

		if (cloudPoint.Y_m < mMinY)
			mMinY = cloudPoint.Y_m;

		if (cloudPoint.Y_m > mMaxY)
			mMaxY = cloudPoint.Y_m;

		if (cloudPoint.Z_m < mMinZ)
			mMinZ = cloudPoint.Z_m;

		if (cloudPoint.Z_m > mMaxZ)
			mMaxZ = cloudPoint.Z_m;
	}
	else
	{
		mHasPoints = true;
		mMinX = mMaxX = cloudPoint.X_m;
		mMinY = mMaxY = cloudPoint.Y_m;
		mMinZ = mMaxZ = cloudPoint.Z_m;
	}

	mCloud.push_back(cloudPoint);
}

