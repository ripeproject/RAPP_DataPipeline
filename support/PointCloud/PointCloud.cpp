
#include "PointCloud.hpp"


/******************************************************************************
 * 
 * Class to store a point clouds generated by generated by a LiDAR sensor.
 * 
 *****************************************************************************/

cPointCloudBase::cPointCloudBase()
{}

void cPointCloudBase::clear()
{
    mCloud.clear();
}

bool cPointCloudBase::empty() const
{
	return mCloud.empty();
}

std::size_t cPointCloudBase::size() const
{
    return mCloud.size();
}


/******************************************************************************
 *
 * Class to store a point clouds generated by one given frame of the sensor.
 * Each point in the point cloud represents one pixel of the sensor.  Invalid
 * points are stored as x=0, y=0, and z=0.
 *
 *****************************************************************************/

cSensorPointCloudByFrame::cSensorPointCloudByFrame()
    : mFrameID(0), mTimestamp_ns(0), mNumOfPixelsPerColumn(0), mNumOfCols(0)
{}

void cSensorPointCloudByFrame::frameID(uint16_t id)
{
    mFrameID = id;
}

void cSensorPointCloudByFrame::timestamp_ns(uint64_t ts)
{
    mTimestamp_ns = ts;
}


std::size_t cSensorPointCloudByFrame::pixelsPerColumn() const
{
	return mNumOfPixelsPerColumn;
}

std::size_t cSensorPointCloudByFrame::columnsPerFrame() const
{
	return mNumOfCols;
}

void cSensorPointCloudByFrame::resize(std::uint16_t pixels_per_column, uint16_t columns_per_frame)
{
	mNumOfPixelsPerColumn = pixels_per_column;
	mNumOfCols = columns_per_frame;
	mCloud.resize(pixels_per_column * columns_per_frame);
}

template<typename T>
inline ouster::view<T> ouster::matrix_col_major<T>::row(std::size_t r) const
{
	return view<T>(&mData[r], &mData[(mNumOfCols - 1) * mNumOfPixelsPerColumn + r], mNumOfPixelsPerColumn);
}

template<typename T>
inline ouster::span<T> ouster::matrix_col_major<T>::row(std::size_t r)
{
	return span<T>(&mData[r], &mData[(mNumOfCols - 1) * mNumOfPixelsPerColumn + r], mNumOfPixelsPerColumn);
}

template<typename T>
inline ouster::view<T> ouster::matrix_col_major<T>::column(std::size_t c) const
{
	return view<T>(&mData[c * mNumOfPixelsPerColumn], &mData[(c + 1) * mNumOfPixelsPerColumn - 1], 1);
}

template<typename T>
inline ouster::span<T> ouster::matrix_col_major<T>::column(std::size_t c)
{
	return span<T>(&mData[c * mNumOfPixelsPerColumn], &mData[(c + 1) * mNumOfPixelsPerColumn - 1], 1);
}

template<typename T>
inline const typename ouster::matrix_col_major<T>::value_type& ouster::matrix_col_major<T>::get(std::size_t row, std::size_t col) const
{
	return mData[row + col * mNumOfPixelsPerColumn];
}

template<typename T>
void ouster::matrix_col_major<T>::set(std::size_t row, std::size_t col, const value_type& v)
{
	mData[row + col * mNumOfPixelsPerColumn] = v;
}



/******************************************************************************
 *
 * Class to store a reduced point clouds generated by one given frame of the sensor.
 * Invalid points (x=0, y=0, and z=0) are not stored in the point cloud.
 *
 *****************************************************************************/

cReducedPointCloudByFrame::cReducedPointCloudByFrame()
    : mFrameID(0), mTimestamp_ns(0)
{}

void cReducedPointCloudByFrame::frameID(uint16_t id)
{
    mFrameID = id;
}

void cReducedPointCloudByFrame::timestamp_ns(uint64_t ts)
{
    mTimestamp_ns = ts;
}

void cReducedPointCloudByFrame::resize(std::size_t num_of_points)
{
	mCloud.resize(num_of_points);
}

void cReducedPointCloudByFrame::set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint)
{
	if (point < mCloud.size())
		mCloud[point] = cloudPoint;
}

void cReducedPointCloudByFrame::addPoint(const pointcloud::sCloudPoint_t& cloudPoint)
{
    if ((cloudPoint.X_m == 0.0) && (cloudPoint.Y_m == 0.0) && (cloudPoint.Z_m == 0.0))
        return;

    mCloud.push_back(cloudPoint);
}

/******************************************************************************
 *
 * Class to store a point clouds generated by one given frame of the sensor.
 *
 *****************************************************************************/

void cPointCloud::resize(std::size_t num_of_points)
{
	mCloud.resize(num_of_points);
}

void cPointCloud::set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint)
{
	if (point < mCloud.size())
		mCloud[point] = cloudPoint;
}

void cPointCloud::addPoint(const pointcloud::sCloudPoint_t& cloudPoint)
{
    mCloud.push_back(cloudPoint);
}

