#pragma once

#include "PointCloudTypes.hpp"

#include <vector>


/**
 * Class to store a point clouds generated by a LiDAR sensor.
 */
class cPointCloudBase
{
public:
    typedef std::vector<pointcloud::sCloudPoint_t> vCloud_t;

public:
    cPointCloudBase();
    virtual ~cPointCloudBase() = default;

    void clear();

    bool empty() const;
    std::size_t size() const;

    const vCloud_t& data() const { return mCloud; }

protected:
    vCloud_t mCloud;
};








/**
 * Class to store a point clouds generated by one given frame of the sensor.
 * Each point in the point cloud represents one pixel of the sensor.  Invalid
 * points are stored as x=0, y=0, and z=0.
 */
class cSensorPointCloudByFrame : public cPointCloudBase
{
public:
	struct Iterator
	{
		// Iterator tags here...
		using iterator_category = std::bidirectional_iterator_tag;
		using difference_type = std::ptrdiff_t;
		using value_type = pointcloud::sCloudPoint_t;
		using pointer = pointcloud::sCloudPoint_t*;
		using reference = pointcloud::sCloudPoint_t&;

		Iterator(pointer pos, std::size_t stride) : mpPos(pos), mStride(stride) {}

		reference operator*() const { return *mpPos; }
		pointer operator->() { return mpPos; }

		// Prefix increment
		Iterator& operator++() { mpPos += mStride; return *this; }
		Iterator& operator--() { mpPos -= mStride; return *this; }

		// Postfix increment
		Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }
		Iterator operator--(int) { Iterator tmp = *this; --(*this); return tmp; }

		friend bool operator== (const Iterator& a, const Iterator& b) { return a.mpPos == b.mpPos; };
		friend bool operator!= (const Iterator& a, const Iterator& b) { return a.mpPos != b.mpPos; };

	private:
		pointer mpPos;
		std::size_t mStride;
	};

	class view
	{
	public:
		using value_type = pointcloud::sCloudPoint_t;
		using pointer = pointcloud::sCloudPoint_t*;
		using const_pointer = const pointcloud::sCloudPoint_t*;
		using reference = pointcloud::sCloudPoint_t&;
		using const_reference = const pointcloud::sCloudPoint_t&;
		using difference_type = std::ptrdiff_t;
		using iterator = const Iterator;
		using const_iterator = iterator;
		using reverse_iterator = std::reverse_iterator<iterator>;
		using const_reverse_iterator = std::reverse_iterator<const_iterator>;
		using iterator_category = typename iterator::iterator_category;

		bool empty() const;
		std::size_t size() const;

		iterator begin() const { return cbegin(); };
		iterator end() const { return cend(); };
		const_iterator cbegin() const { return Iterator(const_cast<pointer>(mpStart), mStride); };
		const_iterator cend() const { return Iterator(const_cast<pointer>(mpLast + mStride), mStride); };

		reverse_iterator rbegin() const { return crbegin(); };
		reverse_iterator rend() const { return crend(); };
		const_reverse_iterator crbegin() const { return reverse_iterator(Iterator(const_cast<pointer>(mpLast + mStride), mStride)); };
		const_reverse_iterator crend() const { return reverse_iterator(Iterator(const_cast<pointer>(mpStart), mStride)); };

		const_reference operator[](std::size_t i) const;

	protected:
		view(const_pointer start, const_pointer last, std::size_t stride = 1);

	private:
		const_pointer mpStart;
		const_pointer mpLast;
		std::size_t mStride;

		friend class cSensorPointCloudByFrame;
		friend class span;
	};

	class span
	{
	public:
		using value_type = pointcloud::sCloudPoint_t;
		using pointer = pointcloud::sCloudPoint_t*;
		using const_pointer = const pointcloud::sCloudPoint_t*;
		using reference = pointcloud::sCloudPoint_t&;
		using const_reference = const pointcloud::sCloudPoint_t&;
		using difference_type = std::ptrdiff_t;
		using iterator = Iterator;
		using const_iterator = const iterator;
		using reverse_iterator = std::reverse_iterator<iterator>;
		using const_reverse_iterator = std::reverse_iterator<const_iterator>;
		using iterator_category = typename iterator::iterator_category;

		bool empty() const;
		std::size_t size() const;

		iterator begin() { return Iterator(mpStart, mStride); };
		iterator end() { return Iterator(mpLast + mStride, mStride); };
		const_iterator begin() const { return cbegin(); };
		const_iterator end() const { return cend(); };
		const_iterator cbegin() const { return Iterator(mpStart, mStride); };
		const_iterator cend() const { return Iterator(mpLast + mStride, mStride); };

		reverse_iterator rbegin() { return reverse_iterator(Iterator(mpLast + mStride, mStride)); };
		reverse_iterator rend() { return reverse_iterator(Iterator(mpStart, mStride)); };
		const_reverse_iterator rbegin() const { return crbegin(); };
		const_reverse_iterator rend() const { return crend(); };
		const_reverse_iterator crbegin() const { return reverse_iterator(Iterator(mpLast + mStride, mStride)); };
		const_reverse_iterator crend() const { return reverse_iterator(Iterator(mpStart, mStride)); };

		const_reference operator[](std::size_t i) const;
		reference operator[](std::size_t i);

		view to_view() const;

	protected:
		span(pointer start, pointer last, std::size_t stride = 1);

	private:
		pointer mpStart;
		pointer mpLast;
		std::size_t mStride;

		friend class cSensorPointCloudByFrame;
	};


public:
    cSensorPointCloudByFrame();
	virtual ~cSensorPointCloudByFrame() {};

    std::size_t channelsPerColumn() const;
    std::size_t columnsPerFrame() const;

    void resize(uint16_t pixels_per_column, uint16_t columns_per_frame);

    uint16_t frameID() const { return mFrameID; }
    void frameID(uint16_t id);

    uint64_t timestamp_ns() const { return mTimestamp_ns; }
    void timestamp_ns(uint64_t ts);

	cSensorPointCloudByFrame::view channels(uint16_t column) const;
	cSensorPointCloudByFrame::span channels(uint16_t column);

	const pointcloud::sCloudPoint_t& get(uint16_t column, uint16_t chn) const;
	void set(uint16_t column, uint16_t chn, const pointcloud::sCloudPoint_t& v);

private:
    uint16_t mFrameID;
    uint64_t mTimestamp_ns;

    std::size_t mNumOfChannelsPerColumn;
	std::size_t mNumOfColumnsPerFrame;
};


/**
 * Class to store a reduced point clouds generated by one given frame of the sensor.
 * Invalid points (x=0, y=0, and z=0) are not stored in the point cloud.
 */
class cReducedPointCloudByFrame : public cPointCloudBase
{
public:
    cReducedPointCloudByFrame();

    uint16_t frameID() const { return mFrameID; }
    void frameID(uint16_t id);

    uint64_t timestamp_ns() const { return mTimestamp_ns; }
    void timestamp_ns(uint64_t ts);

    void resize(std::size_t num_of_points);

    void set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint);

    void addPoint(const pointcloud::sCloudPoint_t& cloudPoint);

private:
    uint16_t mFrameID;
    uint64_t mTimestamp_ns;
};


/**
 * Class to store a point clouds generated by one given frame of the sensor.
 */
class cPointCloud : public cPointCloudBase
{
public:
    cPointCloud() = default;

    void resize(std::size_t num_of_points);

    void set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint);

    void addPoint(const pointcloud::sCloudPoint_t& cloudPoint);
};



