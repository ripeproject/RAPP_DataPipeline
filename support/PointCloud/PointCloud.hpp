#pragma once

#include "PointCloudTypes.hpp"

#include <vector>
#include <cassert>


/**
 * Class to store a point clouds generated by a LiDAR sensor.
 */
template<class POINT>
class cBasePointCloud
{
public:
	typedef POINT				value_type;
	typedef std::vector<POINT>  vCloud_t;

public:
	cBasePointCloud();
    virtual ~cBasePointCloud() = default;

    void clear();

    bool empty() const;
    std::size_t size() const;

	double minX() const;
	double maxX() const;

	double minY() const;
	double maxY() const;

	double minZ() const;
	double maxZ() const;

    const vCloud_t& data() const { return mCloud; }

protected:
	bool mHasPoints = false;

	double mMinX = 0.0;
	double mMaxX = 0.0;

	double mMinY = 0.0;
	double mMaxY = 0.0;

	double mMinZ = 0.0;
	double mMaxZ = 0.0;
	
	vCloud_t mCloud;
};


/**
 * Class to store a point clouds generated by one given frame of the sensor.
 * Each point in the point cloud represents one pixel of the sensor.  Invalid
 * points are stored as x=0, y=0, and z=0.
 */
template<class POINT>
class cPointCloudByFrame : public cBasePointCloud<POINT>
{
public:
	using value_type = POINT;

	struct Iterator
	{
		// Iterator tags here...
		using iterator_category = std::bidirectional_iterator_tag;
		using difference_type = std::ptrdiff_t;
		using value_type = POINT;
		using pointer = POINT*;
		using reference = POINT&;

		Iterator(pointer pos, std::size_t stride) : mpPos(pos), mStride(stride) {}

		reference operator*() const { return *mpPos; }
		pointer operator->() { return mpPos; }

		// Prefix increment
		Iterator& operator++() { mpPos += mStride; return *this; }
		Iterator& operator--() { mpPos -= mStride; return *this; }

		// Postfix increment
		Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }
		Iterator operator--(int) { Iterator tmp = *this; --(*this); return tmp; }

		friend bool operator== (const Iterator& a, const Iterator& b) { return a.mpPos == b.mpPos; };
		friend bool operator!= (const Iterator& a, const Iterator& b) { return a.mpPos != b.mpPos; };

	private:
		pointer mpPos;
		std::size_t mStride;
	};

	class view
	{
	public:
		using value_type = POINT;
		using pointer = POINT*;
		using const_pointer = const POINT*;
		using reference = POINT&;
		using const_reference = const POINT&;
		using difference_type = std::ptrdiff_t;
		using iterator = const Iterator;
		using const_iterator = iterator;
		using reverse_iterator = std::reverse_iterator<iterator>;
		using const_reverse_iterator = std::reverse_iterator<const_iterator>;
		using iterator_category = typename iterator::iterator_category;

		bool empty() const;
		std::size_t size() const;

		iterator begin() const { return cbegin(); };
		iterator end() const { return cend(); };
		const_iterator cbegin() const { return Iterator(const_cast<pointer>(mpStart), mStride); };
		const_iterator cend() const { return Iterator(const_cast<pointer>(mpLast + mStride), mStride); };

		reverse_iterator rbegin() const { return crbegin(); };
		reverse_iterator rend() const { return crend(); };
		const_reverse_iterator crbegin() const { return reverse_iterator(Iterator(const_cast<pointer>(mpLast + mStride), mStride)); };
		const_reverse_iterator crend() const { return reverse_iterator(Iterator(const_cast<pointer>(mpStart), mStride)); };

		const_reference operator[](std::size_t i) const;

	protected:
		view(const_pointer start, const_pointer last, std::size_t stride = 1);

	private:
		const_pointer mpStart;
		const_pointer mpLast;
		std::size_t mStride;

		friend class cPointCloudByFrame;
		friend class span;
	};

	class span
	{
	public:
		using value_type = POINT;
		using pointer = POINT*;
		using const_pointer = const POINT*;
		using reference = POINT&;
		using const_reference = const POINT&;
		using difference_type = std::ptrdiff_t;
		using iterator = Iterator;
		using const_iterator = const iterator;
		using reverse_iterator = std::reverse_iterator<iterator>;
		using const_reverse_iterator = std::reverse_iterator<const_iterator>;
		using iterator_category = typename iterator::iterator_category;

		bool empty() const;
		std::size_t size() const;

		iterator begin() { return Iterator(mpStart, mStride); };
		iterator end() { return Iterator(mpLast + mStride, mStride); };
		const_iterator begin() const { return cbegin(); };
		const_iterator end() const { return cend(); };
		const_iterator cbegin() const { return Iterator(mpStart, mStride); };
		const_iterator cend() const { return Iterator(mpLast + mStride, mStride); };

		reverse_iterator rbegin() { return reverse_iterator(Iterator(mpLast + mStride, mStride)); };
		reverse_iterator rend() { return reverse_iterator(Iterator(mpStart, mStride)); };
		const_reverse_iterator rbegin() const { return crbegin(); };
		const_reverse_iterator rend() const { return crend(); };
		const_reverse_iterator crbegin() const { return reverse_iterator(Iterator(mpLast + mStride, mStride)); };
		const_reverse_iterator crend() const { return reverse_iterator(Iterator(mpStart, mStride)); };

		const_reference operator[](std::size_t i) const;
		reference operator[](std::size_t i);

		view to_view() const;

	protected:
		span(pointer start, pointer last, std::size_t stride = 1);

	private:
		pointer mpStart;
		pointer mpLast;
		std::size_t mStride;

		friend class cPointCloudByFrame;
	};


public:
    cPointCloudByFrame();
	virtual ~cPointCloudByFrame() {};

    std::size_t channelsPerColumn() const;
    std::size_t columnsPerFrame() const;

    void resize(uint16_t pixels_per_column, uint16_t columns_per_frame);

    uint16_t frameID() const { return mFrameID; }
    void frameID(uint16_t id);

    uint64_t timestamp_ns() const { return mTimestamp_ns; }
    void timestamp_ns(uint64_t ts);

	cPointCloudByFrame<POINT>::view channels(uint16_t column) const;
	cPointCloudByFrame<POINT>::span channels(uint16_t column);

	const POINT& get(uint16_t column, uint16_t chn) const;
	void set(uint16_t column, uint16_t chn, const POINT& v);

private:
    uint16_t mFrameID;
    uint64_t mTimestamp_ns;

    std::size_t mNumOfChannelsPerColumn;
	std::size_t mNumOfColumnsPerFrame;
};

class cSensorPointCloudByFrame : public cPointCloudByFrame<pointcloud::sCloudPoint_t>
{};

class cSensorPointCloudByFrame_FrameId : public cPointCloudByFrame<pointcloud::sCloudPoint_FrameID_t>
{};

class cSensorPointCloudByFrame_SensorInfo : public cPointCloudByFrame<pointcloud::sCloudPoint_SensorInfo_t>
{};


/**
 * Class to store a reduced point clouds generated by one given frame of the sensor.
 * Invalid points (x=0, y=0, and z=0) are not stored in the point cloud.
 */
class cReducedPointCloudByFrame : public cBasePointCloud<pointcloud::sCloudPoint_t>
{
public:
    cReducedPointCloudByFrame();

    uint16_t frameID() const { return mFrameID; }
    void frameID(uint16_t id);

    uint64_t timestamp_ns() const { return mTimestamp_ns; }
    void timestamp_ns(uint64_t ts);

    void resize(std::size_t num_of_points);

    void set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint);

    void addPoint(const pointcloud::sCloudPoint_t& cloudPoint);

private:
    uint16_t mFrameID;
    uint64_t mTimestamp_ns;
};


class cReducedPointCloudByFrame_FrameId : public cBasePointCloud<pointcloud::sCloudPoint_FrameID_t>
{
public:
	cReducedPointCloudByFrame_FrameId();

	uint16_t frameID() const { return mFrameID; }
	void frameID(uint16_t id);

	uint64_t timestamp_ns() const { return mTimestamp_ns; }
	void timestamp_ns(uint64_t ts);

	void resize(std::size_t num_of_points);

	void set(std::size_t point, const pointcloud::sCloudPoint_FrameID_t& cloudPoint);

	void addPoint(const pointcloud::sCloudPoint_FrameID_t& cloudPoint);

private:
	uint16_t mFrameID;
	uint64_t mTimestamp_ns;
};


class cReducedPointCloudByFrame_SensorInfo : public cBasePointCloud<pointcloud::sCloudPoint_SensorInfo_t>
{
public:
	cReducedPointCloudByFrame_SensorInfo();

	uint16_t frameID() const { return mFrameID; }
	void frameID(uint16_t id);

	uint64_t timestamp_ns() const { return mTimestamp_ns; }
	void timestamp_ns(uint64_t ts);

	void resize(std::size_t num_of_points);

	void set(std::size_t point, const pointcloud::sCloudPoint_SensorInfo_t& cloudPoint);

	void addPoint(const pointcloud::sCloudPoint_SensorInfo_t& cloudPoint);

private:
	uint16_t mFrameID;
	uint64_t mTimestamp_ns;
};


/**
 * Class to store a point clouds generated by one given frame of the sensor.
 */
class cPointCloud : public cBasePointCloud<pointcloud::sCloudPoint_t>
{
public:
    cPointCloud() = default;

    void resize(std::size_t num_of_points);

    void set(std::size_t point, const pointcloud::sCloudPoint_t& cloudPoint);

    void addPoint(const pointcloud::sCloudPoint_t& cloudPoint);
};

class cPointCloud_FrameId : public cBasePointCloud<pointcloud::sCloudPoint_FrameID_t>
{
public:
	cPointCloud_FrameId() = default;

	void resize(std::size_t num_of_points);

	void set(std::size_t point, const pointcloud::sCloudPoint_FrameID_t& cloudPoint);

	void addPoint(const pointcloud::sCloudPoint_FrameID_t& cloudPoint);
};

class cPointCloud_SensorInfo : public cBasePointCloud<pointcloud::sCloudPoint_SensorInfo_t>
{
public:
	cPointCloud_SensorInfo() = default;

	void resize(std::size_t num_of_points);

	void set(std::size_t point, const pointcloud::sCloudPoint_SensorInfo_t& cloudPoint);

	void addPoint(const pointcloud::sCloudPoint_SensorInfo_t& cloudPoint);
};



///////////////////////////////////////////////////////////////////////////////
// Implementation Details
///////////////////////////////////////////////////////////////////////////////

template<class POINT>
cBasePointCloud<POINT>::cBasePointCloud()
{
	mHasPoints = false;
	mMinX = mMaxX = 0.0;
	mMinY = mMaxY = 0.0;
	mMinZ = mMaxZ = 0.0;
}

template<class POINT>
void cBasePointCloud<POINT>::clear()
{
	mCloud.clear();

	mHasPoints = false;
	mMinX = mMaxX = 0.0;
	mMinY = mMaxY = 0.0;
	mMinZ = mMaxZ = 0.0;
}

template<class POINT>
bool cBasePointCloud<POINT>::empty() const { return mCloud.empty(); }

template<class POINT>
std::size_t cBasePointCloud<POINT>::size() const { return mCloud.size(); }

template<class POINT>
double cBasePointCloud<POINT>::minX() const { return mMinX; }

template<class POINT>
double cBasePointCloud<POINT>::maxX() const { return mMaxX; }

template<class POINT>
double cBasePointCloud<POINT>::minY() const { return mMinY; }

template<class POINT>
double cBasePointCloud<POINT>::maxY() const { return mMaxY; }

template<class POINT>
double cBasePointCloud<POINT>::minZ() const { return mMinZ; }

template<class POINT>
double cBasePointCloud<POINT>::maxZ() const { return mMaxZ; }


/******************************************************************************
 *
 * Class to store a point clouds generated by generated by a LiDAR sensor.
 *
 *****************************************************************************/

 /******************************************************************************
  *
  * Class to store a point clouds generated by one given frame of the sensor.
  * Each point in the point cloud represents one pixel of the sensor.  Invalid
  * points are stored as x=0, y=0, and z=0.
  *
  *****************************************************************************/


  /////////////////////////////////////////////////////////////////////////////////////
  // View
  /////////////////////////////////////////////////////////////////////////////////////

template<class POINT>
cPointCloudByFrame<POINT>::view::view(const_pointer start, const_pointer last, std::size_t stride)
	: mpStart(start), mpLast(last), mStride(stride)
{}

template<class POINT>
bool cPointCloudByFrame<POINT>::view::empty() const
{
	return mpLast == mpStart;
}

template<class POINT>
std::size_t cPointCloudByFrame<POINT>::view::size() const
{
	if (mpLast == mpStart) return 0;
	return (std::distance(mpStart, mpLast) / mStride) + 1;
}

template<class POINT>
cPointCloudByFrame<POINT>::view::const_reference cPointCloudByFrame<POINT>::view::operator[](std::size_t i) const
{
	return *(mpStart + i * mStride);
}


/////////////////////////////////////////////////////////////////////////////////////
// Span
/////////////////////////////////////////////////////////////////////////////////////
template<class POINT>
cPointCloudByFrame<POINT>::span::span(pointer start, pointer last, std::size_t stride)
	: mpStart(start), mpLast(last), mStride(stride)
{}

template<class POINT>
bool cPointCloudByFrame<POINT>::span::empty() const
{
	return mpLast == mpStart;
}

template<class POINT>
std::size_t cPointCloudByFrame<POINT>::span::size() const
{
	if (mpLast == mpStart) return 0;
	return (std::distance(mpStart, mpLast) / mStride) + 1;
}

template<class POINT>
cPointCloudByFrame<POINT>::span::const_reference cPointCloudByFrame<POINT>::span::operator[](std::size_t i) const
{
	return *(mpStart + i * mStride);
}

template<class POINT>
cPointCloudByFrame<POINT>::span::reference cPointCloudByFrame<POINT>::span::operator[](std::size_t i)
{
	return *(mpStart + i * mStride);
}

template<class POINT>
cPointCloudByFrame<POINT>::view cPointCloudByFrame<POINT>::span::to_view() const
{
	return view(mpStart, mpLast, mStride);
}


/////////////////////////////////////////////////////////////////////////////////////
// Point Cloud By Frame
/////////////////////////////////////////////////////////////////////////////////////
template<class POINT>
cPointCloudByFrame<POINT>::cPointCloudByFrame()
	: cBasePointCloud<POINT>(), mFrameID(0), mTimestamp_ns(0), mNumOfChannelsPerColumn(0), mNumOfColumnsPerFrame(0)
{}

template<class POINT>
void cPointCloudByFrame<POINT>::frameID(uint16_t id)
{
	mFrameID = id;
}

template<class POINT>
void cPointCloudByFrame<POINT>::timestamp_ns(uint64_t ts)
{
	mTimestamp_ns = ts;
}

template<class POINT>
std::size_t cPointCloudByFrame<POINT>::channelsPerColumn() const
{
	return mNumOfChannelsPerColumn;
}

template<class POINT>
std::size_t cPointCloudByFrame<POINT>::columnsPerFrame() const
{
	return mNumOfColumnsPerFrame;
}

template<class POINT>
void cPointCloudByFrame<POINT>::resize(std::uint16_t pixels_per_column, uint16_t columns_per_frame)
{
	mNumOfChannelsPerColumn = pixels_per_column;
	mNumOfColumnsPerFrame = columns_per_frame;
	cBasePointCloud<POINT>::mCloud.resize(pixels_per_column * columns_per_frame);
}

template<class POINT>
cPointCloudByFrame<POINT>::view cPointCloudByFrame<POINT>::channels(uint16_t column) const
{
	return view(&cBasePointCloud<POINT>::mCloud[column * mNumOfChannelsPerColumn],
		&cBasePointCloud<POINT>::mCloud[(column + 1) * mNumOfChannelsPerColumn - 1], 1);
}

template<class POINT>
cPointCloudByFrame<POINT>::span cPointCloudByFrame<POINT>::channels(uint16_t column)
{
	return span(&cBasePointCloud<POINT>::mCloud[column * mNumOfChannelsPerColumn],
		&cBasePointCloud<POINT>::mCloud[(column + 1) * mNumOfChannelsPerColumn - 1], 1);
}

template<class POINT>
const POINT& cPointCloudByFrame<POINT>::get(uint16_t column, uint16_t chn) const
{
	return cBasePointCloud<POINT>::mCloud[chn + column * mNumOfChannelsPerColumn];
}

template<class POINT>
void cPointCloudByFrame<POINT>::set(uint16_t column, uint16_t chn, const POINT& v)
{
	assert(chn < mNumOfChannelsPerColumn);
	assert(column < mNumOfColumnsPerFrame);

	if (cBasePointCloud<POINT>::mHasPoints)
	{
		if (v.X_m < cBasePointCloud<POINT>::mMinX)
			cBasePointCloud<POINT>::mMinX = v.X_m;

		if (v.X_m > cBasePointCloud<POINT>::mMaxX)
			cBasePointCloud<POINT>::mMaxX = v.X_m;

		if (v.Y_m < cBasePointCloud<POINT>::mMinY)
			cBasePointCloud<POINT>::mMinY = v.Y_m;

		if (v.Y_m > cBasePointCloud<POINT>::mMaxY)
			cBasePointCloud<POINT>::mMaxY = v.Y_m;

		if (v.Z_m < cBasePointCloud<POINT>::mMinZ)
			cBasePointCloud<POINT>::mMinZ = v.Z_m;

		if (v.Z_m > cBasePointCloud<POINT>::mMaxZ)
			cBasePointCloud<POINT>::mMaxZ = v.Z_m;
	}
	else
	{
		cBasePointCloud<POINT>::mHasPoints = true;
		cBasePointCloud<POINT>::mMinX = cBasePointCloud<POINT>::mMaxX = v.X_m;
		cBasePointCloud<POINT>::mMinY = cBasePointCloud<POINT>::mMaxY = v.Y_m;
		cBasePointCloud<POINT>::mMinZ = cBasePointCloud<POINT>::mMaxZ = v.Z_m;
	}

	cBasePointCloud<POINT>::mCloud[chn + column * mNumOfChannelsPerColumn] = v;
}


