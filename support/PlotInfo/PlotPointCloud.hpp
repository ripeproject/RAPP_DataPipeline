#pragma once

#include "PlotDataTypes.hpp"
#include "PointCloudTypes.hpp"
#include "PointCloud.hpp"

#include "Constants.hpp"

#include <vector>
#include <cassert>
#include <string>


/**
 * Class to store a plot point clouds generated by a LiDAR sensor.
 */
class cPlotPointCloud
{
public:
	typedef std::vector<plot::sPoint3D_t>  vCloud_t;

	typedef std::vector<plot::sPoint3D_t>::value_type				value_type;
	typedef std::vector<plot::sPoint3D_t>::size_type				size_type;
	typedef std::vector<plot::sPoint3D_t>::difference_type			difference_type;
	typedef std::vector<plot::sPoint3D_t>::reference				reference;
	typedef std::vector<plot::sPoint3D_t>::const_reference			const_reference;
	typedef std::vector<plot::sPoint3D_t>::pointer					pointer;
	typedef std::vector<plot::sPoint3D_t>::const_pointer			const_pointer;
	typedef std::vector<plot::sPoint3D_t>::iterator					iterator;
	typedef std::vector<plot::sPoint3D_t>::const_iterator			const_iterator;
	typedef std::vector<plot::sPoint3D_t>::reverse_iterator			reverse_iterator;
	typedef std::vector<plot::sPoint3D_t>::const_reverse_iterator	const_reverse_iterator;

public:
	cPlotPointCloud();
	cPlotPointCloud(const cPlotPointCloud& pc) = default;
	~cPlotPointCloud();

	explicit cPlotPointCloud(plot::sCentroid_t centroid, const vCloud_t& pc);
	explicit cPlotPointCloud(const cBasePointCloud<pointcloud::sCloudPoint_t>& pc);
	explicit cPlotPointCloud(const cBasePointCloud<pointcloud::sCloudPoint_FrameID_t>& pc);
	explicit cPlotPointCloud(const cBasePointCloud<pointcloud::sCloudPoint_SensorInfo_t>& pc);

	cPlotPointCloud& operator=(const cPlotPointCloud& pc) = default;

	bool vegetationOnly() const;
	void setVegetationOnly(const bool vegetation_only);

	bool hasFrameIDs() const;
	bool hasPixelInfo() const;

    void clear();

    bool empty() const;

	void reserve(size_type new_cap);
	void resize(size_type count);
	void resize(size_type count, const value_type& value);

	size_type size() const;

	void push_back(const value_type& value);
	void addPoint(const plot::sPoint3D_t& cloudPoint);

	const cPlotPointCloud& operator+=(const cPlotPointCloud& pc);

	/** SpiderCam uses millimeters **/
	int minX_mm() const;
	int maxX_mm() const;

	int minY_mm() const;
	int maxY_mm() const;

	int minZ_mm() const;
	int maxZ_mm() const;

	int length_mm() const;
	int width_mm() const;
	int height_mm() const;

	void recomputeBounds();

	plot::rappPoint_t center() const;

	plot::sCentroid_t centroid() const;

	plot::sPoint3D_t getPoint(int x_mm, int y_mm, int r_mm) const;

	iterator begin() { return mCloud.begin(); }
	const_iterator begin() const { return mCloud.begin(); }
	const_iterator cbegin() { return mCloud.cbegin(); }

	iterator end() { return mCloud.end(); }
	const_iterator end() const { return mCloud.end(); }
	const_iterator cend() { return mCloud.cend(); }

	reverse_iterator rbegin() { return mCloud.rbegin(); }
	const_reverse_iterator rbegin() const { return mCloud.rbegin(); }
	const_reverse_iterator crbegin() { return mCloud.crbegin(); }

	reverse_iterator rend() { return mCloud.rend(); }
	const_reverse_iterator rend() const { return mCloud.rend(); }
	const_reverse_iterator crend() { return mCloud.crend(); }

	plot::sPoint3D_t& operator[](int i)       { return mCloud[i]; }
	plot::sPoint3D_t  operator[](int i) const { return mCloud[i]; }

    const vCloud_t& data() const { return mCloud; }

	void disableFrameIDs();
	void enableFrameIDs();

	void disablePixelInfo();
	void enablePixelInfo();

protected:
	template<class POINT2>
	void assign(const cBasePointCloud<POINT2>& pc);

private:
	int mMinX_mm = 0;
	int mMaxX_mm = 0;

	int mMinY_mm = 0;
	int mMaxY_mm = 0;

	int mMinZ_mm = 0;
	int mMaxZ_mm = 0;

	plot::sCentroid_t mCentroid;

	bool mHasFrameIDs  = false;
	bool mHasPixelInfo = false;

	bool mEnableFrameIDs = true;
	bool mEnablePixelInfo = true;

	bool mVegetationOnly = false;

	vCloud_t mCloud;
};


///////////////////////////////////////////////////////////////////////////////
// Implementation Details
///////////////////////////////////////////////////////////////////////////////

template<class POINT2>
void cPlotPointCloud::assign(const cBasePointCloud<POINT2>& pc)
{
	mMinX_mm = static_cast<int>(pc.minX_m() * nConstants::M_TO_MM);
	mMaxX_mm = static_cast<int>(pc.maxX_m() * nConstants::M_TO_MM);

	mMinY_mm = static_cast<int>(pc.minY_m() * nConstants::M_TO_MM);
	mMaxY_mm = static_cast<int>(pc.maxY_m() * nConstants::M_TO_MM);

	mMinZ_mm = static_cast<int>(pc.minZ_m() * nConstants::M_TO_MM);
	mMaxZ_mm = static_cast<int>(pc.maxZ_m() * nConstants::M_TO_MM);

	mCloud.clear();

	auto n = pc.size();
	mCloud.resize(n);

	double sum_x = 0.0;
	double sum_y = 0.0;
	double sum_z = 0.0;

	auto& data = pc.data();
	for (std::size_t i = 0; i < n; ++i)
	{
		POINT2 point = data[i];

		sum_x += point.X_m;
		sum_y += point.Y_m;
		sum_z += point.Z_m;

		mCloud[i] = point;
	}

	double x_mm = (sum_x / n) * nConstants::M_TO_MM;
	double y_mm = (sum_y / n) * nConstants::M_TO_MM;
	double z_mm = (sum_z / n) * nConstants::M_TO_MM;

	mCentroid = { x_mm , y_mm, z_mm };
}

